

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HamGNN_v_2_0.models.HamGNN.Attention_kan &mdash; HamGNN 2.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=8ba3eb92"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/translations.js?v=beaddf03"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            HamGNN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">API 文档</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/main_entry.html">主程序入口</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/model_structure.html">模型顶层结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/gnn_core.html">GNN 核心层</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/model_components.html">模型通用组件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/data_processing.html">数据处理与输入</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/utilities.html">通用工具函数</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">HamGNN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">模块代码</a></li>
      <li class="breadcrumb-item active">HamGNN_v_2_0.models.HamGNN.Attention_kan</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>HamGNN_v_2_0.models.HamGNN.Attention_kan 源代码</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Descripttion: </span>
<span class="sd">version: </span>
<span class="sd">Author: Yang Zhong</span>
<span class="sd">Date: 2024-08-24 20:42:41</span>
<span class="sd">LastEditors: Yang Zhong</span>
<span class="sd">LastEditTime: 2024-10-10 17:43:34</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">nn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">e3nn</span><span class="w"> </span><span class="kn">import</span> <span class="n">o3</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">e3nn.nn</span><span class="w"> </span><span class="kn">import</span> <span class="n">FullyConnectedNet</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">e3nn.math</span><span class="w"> </span><span class="kn">import</span> <span class="n">soft_unit_step</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch_scatter</span><span class="w"> </span><span class="kn">import</span> <span class="n">scatter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">e3nn.util.jit</span><span class="w"> </span><span class="kn">import</span> <span class="n">compile_mode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..Toolbox.nequip.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">AtomicDataDict</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn.functional</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">F</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">..Toolbox.mace.modules.blocks</span><span class="w"> </span><span class="kn">import</span> <span class="n">EquivariantProductBasisBlock</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..Toolbox.mace.modules.irreps_tools</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">linear_out_irreps</span><span class="p">,</span>
    <span class="n">reshape_irreps</span><span class="p">,</span>
    <span class="n">tp_out_irreps_with_instructions</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch_geometric.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">softmax</span> <span class="k">as</span> <span class="n">edge_softmax</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..Toolbox.efficient_kan</span><span class="w"> </span><span class="kn">import</span> <span class="n">KAN</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..Toolbox.nequip.nn.nonlinearities</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShiftedSoftPlus</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">e3nn.nn</span><span class="w"> </span><span class="kn">import</span> <span class="n">Gate</span><span class="p">,</span> <span class="n">NormActivation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..Toolbox.nequip.nn</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphModuleMixin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..layers</span><span class="w"> </span><span class="kn">import</span> <span class="n">cuttoff_envelope</span><span class="p">,</span> <span class="n">CosineCutoff</span>

<span class="n">GRID_SIZE</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">GRID_RANGE</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="TensorExpansion">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.TensorExpansion">[文档]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TensorExpansion</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ham_type</span><span class="p">,</span> <span class="n">nao_max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param ham_type: Type of Hamiltonian (&#39;openmx&#39;, &#39;siesta&#39;, &#39;abacus&#39;, &#39;pasp&#39;)</span>
<span class="sd">        :param nao_max: Maximum number of atomic orbitals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ham_type</span> <span class="o">=</span> <span class="n">ham_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">=</span> <span class="n">nao_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_basis_info</span><span class="p">()</span>
        
        <span class="c1"># Calculate maximum l for Clebsch-Gordan coefficients</span>
        <span class="n">max_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">lmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cg_calculator</span> <span class="o">=</span> <span class="n">ClebschGordanCoefficients</span><span class="p">(</span><span class="n">max_l</span><span class="o">=</span><span class="n">max_l</span><span class="p">)</span>

        <span class="n">irreps_combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_irreps</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">permute_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_permute_indices</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_combined</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_combine_irreps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine input irreps to determine output irreps.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of combined irreps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined_irreps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">li</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">lj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">li</span><span class="o">.</span><span class="n">l</span> <span class="o">-</span> <span class="n">lj</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="n">li</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="n">lj</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">combined_irreps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o3</span><span class="o">.</span><span class="n">Irrep</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">li</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="n">lj</span><span class="o">.</span><span class="n">l</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">combined_irreps</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_index_change_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_change</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the inverse of an index change tensor.</span>

<span class="sd">        :param index_change: Tensor indicating the index change.</span>
<span class="sd">        :return: Tensor representing the inverse index change.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index_change_inv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">index_change</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_change</span><span class="p">)):</span>
            <span class="n">index_change_inv</span><span class="p">[</span><span class="n">index_change</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
        
        <span class="k">return</span> <span class="n">index_change_inv</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_basis_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the basis information based on the Hamiltonian type and number of atomic orbitals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_type</span> <span class="o">==</span> <span class="s1">&#39;openmx&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_openmx_basis</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_type</span> <span class="o">==</span> <span class="s1">&#39;siesta&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_siesta_basis</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_type</span> <span class="o">==</span> <span class="s1">&#39;abacus&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_abacus_basis</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ham_type</span> <span class="o">==</span> <span class="s1">&#39;pasp&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x1o&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hamiltonian type &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ham_type</span><span class="si">}</span><span class="s2">&#39; is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_openmx_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets basis information for &#39;openmx&#39; Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x0e+1x1o+1x1o+1x2e&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x1o+1x1o+1x2e&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">19</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x0e+1x1o+1x1o+1x2e+1x2e&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">26</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">19</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x0e+1x1o+1x1o+1x2e+1x2e+1x3o&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NAO max &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span><span class="si">}</span><span class="s2">&#39; not supported for &#39;openmx&#39;.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_siesta_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets basis information for &#39;siesta&#39; Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x1o+1x1o+1x2e&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">19</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x0e+1x1o+1x1o+1x2e+1x2e&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">17</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NAO max &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span><span class="si">}</span><span class="s2">&#39; not supported for &#39;siesta&#39;.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_abacus_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets basis information for &#39;abacus&#39; Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x1o+1x1o+1x2e&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x0e+1x0e+1x1o+1x1o+1x2e+1x2e+1x3o&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span> <span class="o">==</span> <span class="mi">40</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">33</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s2">&quot;1x0e+1x0e+1x0e+1x0e+1x1o+1x1o+1x1o+1x1o+1x2e+1x2e+1x3o+1x3o&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NAO max &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span><span class="si">}</span><span class="s2">&#39; not supported for &#39;abacus&#39;.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_change_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust the order of the output matrix elements to the atomic orbital order of openmx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;minus_index&#39;</span><span class="p">):</span>
            <span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span><span class="p">)</span>   
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]]</span> 
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;minus_index&#39;</span><span class="p">):</span>
                <span class="n">hamiltonian</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">hamiltonian</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">,:]</span>
                <span class="n">hamiltonian</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">hamiltonian</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">]</span>                
        <span class="k">return</span> <span class="n">hamiltonian</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_change_index_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust the order of the output matrix elements to the atomic orbital order of openmx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;minus_index&#39;</span><span class="p">):</span>
            <span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nao_max</span><span class="p">)</span> 
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;minus_index&#39;</span><span class="p">):</span>
                <span class="n">hamiltonian</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">hamiltonian</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">,:]</span>
                <span class="n">hamiltonian</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">hamiltonian</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">minus_index</span><span class="p">]</span>  
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_change</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_change_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_change_inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_change</span><span class="p">)</span>
                <span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">[:,</span> <span class="n">index_change_inv</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">index_change_inv</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]]</span>               
        <span class="k">return</span> <span class="n">hamiltonian</span>

<div class="viewcode-block" id="TensorExpansion.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.TensorExpansion.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass to compute the expanded tensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (*, row.dim, col.dim).</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Expanded tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_index_inv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="n">output_blocks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">row_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">li</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">li</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">col_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">lj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
                <span class="n">num_cols</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lj</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">li</span><span class="o">.</span><span class="n">l</span> <span class="o">-</span> <span class="n">lj</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="n">li</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="n">lj</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Compute Clebsch-Gordan coefficients</span>
                    <span class="n">cg_coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cg_calculator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">li</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">lj</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
                    <span class="n">block</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">narrow</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">)</span><span class="o">.</span><span class="n">narrow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>
                    <span class="n">output_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nij, kij -&gt; nk&#39;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">cg_coeffs</span><span class="p">))</span>

                <span class="n">col_start</span> <span class="o">+=</span> <span class="n">num_cols</span>
            <span class="n">row_start</span> <span class="o">+=</span> <span class="n">num_rows</span>

        <span class="c1"># Concatenate outputs and apply inverse permutation</span>
        <span class="n">expanded_output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">output_blocks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_permute_indices</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expanded_output</span></div>
</div>


<div class="viewcode-block" id="OverlapExpand">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.OverlapExpand">[文档]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OverlapExpand</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ham_type</span><span class="p">,</span> <span class="n">nao_max</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the OverlapExpand module.</span>

<span class="sd">        :param ham_type: Type of Hamiltonian (&#39;openmx&#39;, &#39;siesta&#39;, &#39;abacus&#39;, &#39;pasp&#39;).</span>
<span class="sd">        :param nao_max: Maximum number of atomic orbitals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor_expansion</span> <span class="o">=</span> <span class="n">TensorExpansion</span><span class="p">(</span><span class="n">ham_type</span><span class="o">=</span><span class="n">ham_type</span><span class="p">,</span> <span class="n">nao_max</span><span class="o">=</span><span class="n">nao_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_expansion</span><span class="o">.</span><span class="n">irreps_out</span>

<div class="viewcode-block" id="OverlapExpand.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.OverlapExpand.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass to expand overlap data.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Object containing &#39;Son&#39; and &#39;Soff&#39; tensors to be expanded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Updated data object with expanded &#39;Son&#39; and &#39;Soff&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Son_expand&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_expansion</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">Son</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Soff_expand&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_expansion</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">Soff</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>
</div>


<div class="viewcode-block" id="ClebschGordanCoefficients">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ClebschGordanCoefficients">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClebschGordanCoefficients</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A PyTorch module for pre-computing and storing Clebsch-Gordan coefficients,</span>
<span class="sd">    which can then be accessed during the forward pass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_l</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the module and pre-compute Clebsch-Gordan coefficients up to a maximum angular momentum value.</span>

<span class="sd">        :param max_l: Maximum angular momentum value for which to compute coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Pre-compute and store all necessary Clebsch-Gordan coefficients</span>
        <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">l3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">),</span> <span class="n">l1</span> <span class="o">+</span> <span class="n">l2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">buffer_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;cg_</span><span class="si">{</span><span class="n">l1</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">l2</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">l3</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="n">buffer_name</span><span class="p">,</span> <span class="n">o3</span><span class="o">.</span><span class="n">wigner_3j</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l3</span><span class="p">))</span>

<div class="viewcode-block" id="ClebschGordanCoefficients.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ClebschGordanCoefficients.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the pre-computed Clebsch-Gordan coefficient for the given angular momenta.</span>

<span class="sd">        :param l1: First angular momentum value.</span>
<span class="sd">        :param l2: Second angular momentum value.</span>
<span class="sd">        :param l3: Third angular momentum value.</span>
<span class="sd">        :return: The Clebsch-Gordan coefficient tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buffer_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;cg_</span><span class="si">{</span><span class="n">l1</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">l2</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">l3</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_name</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="LinearScaleWithWeights">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.LinearScaleWithWeights">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LinearScaleWithWeights</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="n">instructions</span> <span class="o">=</span>  <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;uvu&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">irreps_in</span><span class="p">))]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s1">&#39;1x0e&#39;</span><span class="p">),</span>
            <span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_numel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="o">.</span><span class="n">weight_numel</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
<div class="viewcode-block" id="LinearScaleWithWeights.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.LinearScaleWithWeights.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>


<div class="viewcode-block" id="SoftUnitStepCutoff">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.SoftUnitStepCutoff">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SoftUnitStepCutoff</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A PyTorch module that applies a soft unit step function with a cutoff.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        cutoff (float): The distance at which the cutoff is applied.</span>
<span class="sd">        cut_param (nn.Parameter): A learnable parameter influencing the softness of the step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the SoftUnitStepCutoff module.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            cutoff (float): The cutoff distance for the step function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SoftUnitStepCutoff</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut_param</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">get_default_dtype</span><span class="p">()))</span>

<div class="viewcode-block" id="SoftUnitStepCutoff.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.SoftUnitStepCutoff.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_distance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass for the module.</span>
<span class="sd">        </span>
<span class="sd">        Applies the soft unit step function to the input edge distances.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            edge_distance (Tensor): A tensor containing edge distances.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tensor: A tensor with the calculated edge weights after applying the cutoff.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the scaled difference and apply the soft unit step</span>
        <span class="n">scaled_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_param</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">edge_distance</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="n">edge_weight_cutoff</span> <span class="o">=</span> <span class="n">soft_unit_step</span><span class="p">(</span><span class="n">scaled_diff</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">edge_weight_cutoff</span></div>
</div>


<div class="viewcode-block" id="count_neighbors_per_node">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.count_neighbors_per_node">[文档]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">count_neighbors_per_node</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the number of neighbors for each node.</span>

<span class="sd">    Args:</span>
<span class="sd">        source_nodes (torch.Tensor): A tensor containing source node indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A tensor where each index represents a node and the value</span>
<span class="sd">                      at that index is the count of its neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Identify unique nodes and count their occurrences</span>
    <span class="n">unique_nodes</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Determine the total number of nodes</span>
    <span class="n">total_nodes</span> <span class="o">=</span> <span class="n">source_nodes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Initialize a tensor to store the neighbor counts for each node</span>
    <span class="n">neighbor_counts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">total_nodes</span><span class="p">,))</span><span class="o">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span>

    <span class="c1"># Assign the counts to their respective nodes</span>
    <span class="n">neighbor_counts</span><span class="p">[</span><span class="n">unique_nodes</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>

    <span class="c1"># Ensure the output tensor has the same type as the input</span>
    <span class="k">return</span> <span class="n">neighbor_counts</span></div>


<div class="viewcode-block" id="TensorProductWithMemoryOptimizationWithWeight">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.TensorProductWithMemoryOptimizationWithWeight">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TensorProductWithMemoryOptimizationWithWeight</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_input_1</span><span class="p">,</span> <span class="n">irreps_input_2</span><span class="p">,</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">irreps_scalar</span><span class="p">,</span> <span class="n">radial_MLP</span><span class="p">,</span> <span class="n">use_kan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the TensorProductWithMemoryOptimization module.</span>

<span class="sd">        Args:</span>
<span class="sd">            irreps_input_1 (str): Irreducible representations for the first input.</span>
<span class="sd">            irreps_input_2 (str): Irreducible representations for the second input.</span>
<span class="sd">            irreps_out (str): Irreducible representations for the output.</span>
<span class="sd">            irreps_scalar (str): Irreducible representations for scalar inputs.</span>
<span class="sd">            radial_MLP (list[int]): List of hidden layer sizes for the radial MLP.</span>
<span class="sd">            use_kan (bool): Flag to use KAN instead of FullyConnectedNet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Initialize irreducible representations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_1</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_input_1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_2</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_input_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_scalar</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_scalar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>

        <span class="c1"># Calculate intermediate irreps and instructions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tp_out_irreps_with_instructions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize tensor product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Initialize linear scaling with weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_scaler</span> <span class="o">=</span> <span class="n">LinearScaleWithWeights</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span>
        <span class="p">)</span>

        <span class="c1"># Initialize the weight generator</span>
        <span class="n">input_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_scalar</span><span class="o">.</span><span class="n">num_irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_scaler</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tp_out_irreps_with_instructions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">irreps1</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">irreps2</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">target_irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
        <span class="n">trainable</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Collect possible irreps and their instructions</span>
        <span class="n">irreps_out_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ir_in</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ir_edge</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps2</span><span class="p">):</span>  
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_irreps</span><span class="p">):</span>                  
                    <span class="k">if</span> <span class="n">ir_out</span> <span class="ow">in</span> <span class="n">ir_in</span> <span class="o">*</span> <span class="n">ir_edge</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
                        <span class="n">irreps_out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">))</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;uvw&#39;</span><span class="p">,</span> <span class="n">trainable</span><span class="p">))</span>

        <span class="c1"># We sort the output irreps of the tensor product so that we can simplify them</span>
        <span class="c1"># when they are provided to the second o3.Linear</span>
        <span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
        <span class="n">irreps_out</span><span class="p">,</span> <span class="n">permut</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">irreps_out</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Permute the output indexes of the instructions to match the sorted irreps:</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">permut</span><span class="p">[</span><span class="n">i_out</span><span class="p">],</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span> <span class="ow">in</span> <span class="n">instructions</span>
        <span class="p">]</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">instructions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_weight_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">weight_numel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the weight generator module.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_dim (int): Input dimension size for the weight generator.</span>
<span class="sd">            weight_numel (int): Number of elements in the weight vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nn.Module: Initialized weight generator module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KAN</span><span class="p">([</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span> <span class="n">grid_size</span><span class="o">=</span><span class="n">GRID_SIZE</span><span class="p">,</span> <span class="n">grid_range</span><span class="o">=</span><span class="n">GRID_RANGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TensorProductWithMemoryOptimizationWithWeight.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.TensorProductWithMemoryOptimizationWithWeight.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scalars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the TensorProductWithMemoryOptimization module.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor for the first irreps.</span>
<span class="sd">            y (torch.Tensor): Input tensor for the second irreps.</span>
<span class="sd">            scalars (torch.Tensor): Input tensor of scalars.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor after applying tensor products and scaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate weights using the scalar MLP</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>

        <span class="c1"># Compute tensor products</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_scaler</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="TensorProductWithScalarComponents">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.TensorProductWithScalarComponents">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TensorProductWithScalarComponents</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A module for performing tensor products with memory optimization.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps_input_1 (str): Irreducible representations for the first input.</span>
<span class="sd">    - irreps_input_2 (str): Irreducible representations for the second input.</span>
<span class="sd">    - irreps_out (str): Irreducible representations for the output.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_input_1</span><span class="p">,</span> <span class="n">irreps_input_2</span><span class="p">,</span> <span class="n">irreps_out</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Initialize irreducible representations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_1</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_input_1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_2</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_input_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out</span><span class="p">)</span>

        <span class="c1"># Calculate intermediate irreps and instructions</span>
        <span class="n">irreps_mid_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">mul_1</span><span class="p">,</span> <span class="n">ir_1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">mul_2</span><span class="p">,</span> <span class="n">ir_2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">mul_o</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">):</span>                  
                    <span class="k">if</span> <span class="p">(</span><span class="n">ir_out</span> <span class="ow">in</span> <span class="n">ir_1</span> <span class="o">*</span> <span class="n">ir_2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">ir_1</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">ir_1</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ir_2</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">ir_2</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">irreps_mid_list</span><span class="p">)</span>
                        <span class="n">instructions</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;uvw&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span>
                        <span class="n">irreps_mid_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mul_o</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">))</span>

        <span class="n">irreps_mid</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_mid_list</span><span class="p">)</span>
        <span class="n">irreps_mid</span><span class="p">,</span> <span class="n">permut</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">irreps_mid</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Permute the output indexes of the instructions to match the sorted irreps:</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">permut</span><span class="p">[</span><span class="n">i_out</span><span class="p">],</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span> <span class="ow">in</span> <span class="n">instructions</span>
        <span class="p">]</span>
    
        <span class="n">instructions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Initialize tensor product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_input_2</span><span class="p">,</span>
            <span class="n">irreps_mid</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize linear layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="n">irreps_mid</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TensorProductWithScalarComponents.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.TensorProductWithScalarComponents.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor for the first irreps.</span>
<span class="sd">            y (torch.Tensor): Input tensor for the second irreps.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor after applying tensor products and scaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute tensor products</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="extract_scalar_irreps">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.extract_scalar_irreps">[文档]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_scalar_irreps</span><span class="p">(</span><span class="n">irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts and returns the scalar irreducible representations (irreps) from the given irreps.</span>

<span class="sd">    A scalar irrep is defined as one with l=0 and p=1. This function calculates the total </span>
<span class="sd">    multiplicity of such scalar irreps and constructs a new Irreps object containing only these.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps (o3.Irreps): The input irreps from which to extract scalar components.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - o3.Irreps: An Irreps object containing only the scalar components.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scalar_multiplicity</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="n">multiplicity</span> <span class="k">for</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="n">irreps</span> <span class="k">if</span> <span class="n">irrep</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">irrep</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">scalar_multiplicity</span><span class="si">}</span><span class="s2">x0e&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EdgeScalarEmbedding">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.EdgeScalarEmbedding">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EdgeScalarEmbedding</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A layer to compute edge scalars from node attributes and edge embeddings.</span>

<span class="sd">    Args:</span>
<span class="sd">        irreps_node_attrs (Irreps): Irreps for node attributes.</span>
<span class="sd">        irreps_edge_embed (Irreps): Irreps for edge embeddings.</span>
<span class="sd">        irreps_edge_scalars (Irreps): Irreps for edge scalars.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_node_attrs</span><span class="p">,</span> <span class="n">irreps_edge_embed</span><span class="p">,</span> <span class="n">irreps_edge_scalars</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_node_attrs</span> <span class="o">+</span> <span class="n">irreps_node_attrs</span> <span class="o">+</span> <span class="n">irreps_edge_embed</span><span class="p">,</span> <span class="n">irreps_edge_scalars</span>
        <span class="p">)</span>
        
<div class="viewcode-block" id="EdgeScalarEmbedding.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.EdgeScalarEmbedding.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_attr_src</span><span class="p">,</span> <span class="n">node_attr_dst</span><span class="p">,</span> <span class="n">edge_embed</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass to compute edge scalars.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_attr_src (Tensor): Source node attributes.</span>
<span class="sd">            node_attr_dst (Tensor): Destination node attributes.</span>
<span class="sd">            edge_embed (Tensor): Edge embeddings.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor: Computed edge scalars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined_features</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">node_attr_src</span><span class="p">,</span> <span class="n">node_attr_dst</span><span class="p">,</span> <span class="n">edge_embed</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span><span class="p">(</span><span class="n">combined_features</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="LocalEnvironmentEmbedding">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.LocalEnvironmentEmbedding">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LocalEnvironmentEmbedding</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Embeds local environments using node and edge attributes, edge embeddings, and spherical harmonics.</span>

<span class="sd">    Args:</span>
<span class="sd">        irreps_edge_attrs (Irreps): Irreps for edge attributes.</span>
<span class="sd">        irreps_edge_embed (Irreps): Irreps for edge embeddings.</span>
<span class="sd">        irreps_node_attrs (Irreps): Irreps for node attributes.</span>
<span class="sd">        irreps_edge_scalars (Irreps): Irreps for edge scalars.</span>
<span class="sd">        irreps_env_sh (Irreps): Irreps for environment spherical harmonics.</span>
<span class="sd">        radial_mlp_dims (list[int]): Dimensions for the radial MLP.</span>
<span class="sd">        use_kan (bool): Whether to use the KAN model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_edge_attrs</span><span class="p">,</span> <span class="n">irreps_edge_embed</span><span class="p">,</span> <span class="n">irreps_node_attrs</span><span class="p">,</span>
                 <span class="n">irreps_edge_scalars</span><span class="p">,</span> <span class="n">irreps_env_sh</span><span class="p">,</span> <span class="n">radial_MLP</span><span class="o">=</span><span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span> <span class="n">use_kan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edge_scalar_layer</span> <span class="o">=</span> <span class="n">EdgeScalarEmbedding</span><span class="p">(</span><span class="n">irreps_node_attrs</span><span class="p">,</span> <span class="n">irreps_edge_embed</span><span class="p">,</span> <span class="n">irreps_edge_scalars</span><span class="p">)</span>
        
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;uvw&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">irreps_edge_attrs</span><span class="p">))]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="n">irreps_edge_attrs</span><span class="p">,</span>
            <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="s1">&#39;1x0e&#39;</span><span class="p">),</span>
            <span class="n">irreps_env_sh</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_numel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span><span class="o">.</span><span class="n">weight_numel</span>

        <span class="n">input_dim</span> <span class="o">=</span> <span class="n">irreps_edge_embed</span><span class="o">.</span><span class="n">num_irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">,</span> <span class="n">radial_MLP</span><span class="p">,</span> <span class="n">use_kan</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_weight_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">weight_numel</span><span class="p">,</span> <span class="n">radial_MLP</span><span class="p">,</span> <span class="n">use_kan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the weight generator.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_dim (int): Input dimension for the generator.</span>
<span class="sd">            weight_numel (int): Number of elements in weights.</span>
<span class="sd">            radial_mlp_dims (list[int]): Dimensions for the radial MLP.</span>
<span class="sd">            use_kan (bool): Whether to use the KAN model.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nn.Module: The weight generator model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_kan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KAN</span><span class="p">([</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span> <span class="n">grid_size</span><span class="o">=</span><span class="n">GRID_SIZE</span><span class="p">,</span> <span class="n">grid_range</span><span class="o">=</span><span class="n">GRID_RANGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
        <span class="p">)</span>
        
<div class="viewcode-block" id="LocalEnvironmentEmbedding.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.LocalEnvironmentEmbedding.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">node_attr</span><span class="p">,</span> <span class="n">edge_attr</span><span class="p">,</span> <span class="n">edge_embed</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass to compute local environment embeddings.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_index (Tensor): Indices of the edges.</span>
<span class="sd">            node_attr (Tensor): Node attributes.</span>
<span class="sd">            edge_attr (Tensor): Edge attributes.</span>
<span class="sd">            edge_embed (Tensor): Edge embeddings.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor: Local environment embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">edge_index</span>
        <span class="n">pseudo_scalar</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">edge_embed</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">edge_scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_scalar_layer</span><span class="p">(</span><span class="n">node_attr</span><span class="p">[</span><span class="n">src</span><span class="p">],</span> <span class="n">node_attr</span><span class="p">[</span><span class="n">dst</span><span class="p">],</span> <span class="n">edge_embed</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span><span class="p">(</span><span class="n">edge_scalars</span><span class="p">)</span>
        <span class="n">local_env_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">edge_attr</span><span class="p">,</span> <span class="n">pseudo_scalar</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">local_env_edge</span></div>
</div>


<div class="viewcode-block" id="ConcatenatedIrrepsTensorProduct">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ConcatenatedIrrepsTensorProduct">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ConcatenatedIrrepsTensorProduct</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_in1</span><span class="p">,</span> <span class="n">irreps_in2</span><span class="p">,</span> <span class="n">num_tensors_in1</span><span class="p">,</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">irreps_edge_scalars</span><span class="p">,</span> <span class="n">radial_MLP</span><span class="p">,</span> <span class="n">use_kan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ConcatenatedIrrepsTensorProduct module.</span>

<span class="sd">        Args:</span>
<span class="sd">            irreps_in1 (o3.Irreps): Input irreps for the first input tensor.</span>
<span class="sd">            irreps_in2 (o3.Irreps): Input irreps for the second input tensor.</span>
<span class="sd">            num_tensors_in1 (int): Number of tensors for the first input.</span>
<span class="sd">            irreps_out (o3.Irreps): Desired output irreps.</span>
<span class="sd">            irreps_edge_scalars (o3.Irreps): Edge scalar irreps.</span>
<span class="sd">            radial_mlp (List[int]): Dimensions for the radial MLP.</span>
<span class="sd">            use_kan (bool): Whether to use KAN for weight generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in1</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_in1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in2</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_in2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_scalars</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_scalars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_tensors_in1</span> <span class="o">=</span> <span class="n">num_tensors_in1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in1_combined</span> <span class="o">=</span> <span class="n">scale_irreps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tensors_in1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fuse_in</span> <span class="o">=</span> <span class="n">AttentionHeadsToVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in1</span><span class="p">)</span>
        
        <span class="c1"># Calculate intermediate irreps and instructions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span> <span class="n">_tp_out_irreps_with_instructions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in1_combined</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize tensor product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in1_combined</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Initialize linear scaling with weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_scaler</span> <span class="o">=</span> <span class="n">LinearScaleWithWeights</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span>
        <span class="p">)</span>

        <span class="c1"># Initialize the weight generator</span>
        <span class="n">input_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_scalars</span><span class="o">.</span><span class="n">num_irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_scaler</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">)</span>

        <span class="c1"># linear combination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tp_out_irreps_with_instructions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">irreps1</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">irreps2</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">target_irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
        <span class="n">trainable</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Collect possible irreps and their instructions</span>
        <span class="n">irreps_out_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ir_in</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ir_edge</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps2</span><span class="p">):</span>  
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_irreps</span><span class="p">):</span>                  
                    <span class="k">if</span> <span class="n">ir_out</span> <span class="ow">in</span> <span class="n">ir_in</span> <span class="o">*</span> <span class="n">ir_edge</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
                        <span class="n">irreps_out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">))</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;uvw&#39;</span><span class="p">,</span> <span class="n">trainable</span><span class="p">))</span>

        <span class="c1"># We sort the output irreps of the tensor product so that we can simplify them</span>
        <span class="c1"># when they are provided to the second o3.Linear</span>
        <span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
        <span class="n">irreps_out</span><span class="p">,</span> <span class="n">permut</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">irreps_out</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Permute the output indexes of the instructions to match the sorted irreps:</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">permut</span><span class="p">[</span><span class="n">i_out</span><span class="p">],</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span> <span class="ow">in</span> <span class="n">instructions</span>
        <span class="p">]</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">instructions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_weight_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">weight_numel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the weight generator module.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_dim (int): Input dimension size for the weight generator.</span>
<span class="sd">            weight_numel (int): Number of elements in the weight vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nn.Module: Initialized weight generator module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KAN</span><span class="p">([</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span> <span class="n">grid_size</span><span class="o">=</span><span class="n">GRID_SIZE</span><span class="p">,</span> <span class="n">grid_range</span><span class="o">=</span><span class="n">GRID_RANGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ConcatenatedIrrepsTensorProduct.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ConcatenatedIrrepsTensorProduct.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_tensors1_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">input_tensor2</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">scalars</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass for the ConcatenatedIrrepsTensorProduct module.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_tensors1_list (List[torch.Tensor]): List of tensors for the first input.</span>
<span class="sd">            input_tensor2 (torch.Tensor): Tensor for the second input.</span>
<span class="sd">            scalars (torch.Tensor): Scalar inputs for weight generation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Processed output tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_tensor1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuse_in</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">input_tensors1_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Generate weights using the scalar MLP</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>

        <span class="c1"># Compute tensor products</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">input_tensor1</span><span class="p">,</span> <span class="n">input_tensor2</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_scaler</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="c1"># output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="MessagePackBlock">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.MessagePackBlock">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MessagePackBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_node_feats</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_edge_feats</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_local_env_edge</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_out</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_edge_scalars</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">radial_MLP</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
        <span class="n">use_kan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the MessagePackBlock.</span>

<span class="sd">        Args:</span>
<span class="sd">            irreps_node_feats (str): Irreducible representations for node features.</span>
<span class="sd">            irreps_edge_feats (str): Irreducible representations for edge features.</span>
<span class="sd">            irreps_local_env_edge (str): Irreducible representations for local environment edges.</span>
<span class="sd">            irreps_out (str): Irreducible representations for outputs.</span>
<span class="sd">            irreps_edge_scalars (str): Irreducible representations for edge scalars.</span>
<span class="sd">            radial_mlp_layers (List[int]): Layers for radial MLP.</span>
<span class="sd">            use_kan (bool): Flag to use KAN for weight generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_local_env_edge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_scalars</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_scalars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">combined_node_irreps</span> <span class="o">=</span> <span class="n">scale_irreps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fuse_node</span> <span class="o">=</span> <span class="n">AttentionHeadsToVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">)</span>

        <span class="c1"># Calculate intermediate irreps and instructions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_node_irreps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_instructions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tp_out_irreps_with_instructions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_node_irreps</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_edge_irreps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_instructions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tp_out_irreps_with_instructions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize tensor product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_node_irreps</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_node_irreps</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_edge_irreps</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Initialize linear scaling with weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_scaler</span> <span class="o">=</span> <span class="n">LinearScaleWithWeights</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_node_irreps</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_scaler</span> <span class="o">=</span> <span class="n">LinearScaleWithWeights</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_edge_irreps</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span>
        <span class="p">)</span>

        <span class="c1"># Initialize the weight generator</span>
        <span class="n">input_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_scalars</span><span class="o">.</span><span class="n">num_irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_scaler</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_scaler</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">)</span>

        <span class="c1"># Linear output layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tp_out_irreps_with_instructions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">irreps1</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">irreps2</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">target_irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
        <span class="n">trainable</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Collect possible irreps and their instructions</span>
        <span class="n">irreps_out_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ir_in</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ir_edge</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps2</span><span class="p">):</span>  
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_irreps</span><span class="p">):</span>                  
                    <span class="k">if</span> <span class="n">ir_out</span> <span class="ow">in</span> <span class="n">ir_in</span> <span class="o">*</span> <span class="n">ir_edge</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
                        <span class="n">irreps_out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">))</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;uvw&#39;</span><span class="p">,</span> <span class="n">trainable</span><span class="p">))</span>

        <span class="c1"># We sort the output irreps of the tensor product so that we can simplify them</span>
        <span class="c1"># when they are provided to the second o3.Linear</span>
        <span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
        <span class="n">irreps_out</span><span class="p">,</span> <span class="n">permut</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">irreps_out</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Permute the output indexes of the instructions to match the sorted irreps:</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">permut</span><span class="p">[</span><span class="n">i_out</span><span class="p">],</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">train</span> <span class="ow">in</span> <span class="n">instructions</span>
        <span class="p">]</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">instructions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_weight_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">weight_numel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the weight generator module.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_dim (int): Input dimension size for the weight generator.</span>
<span class="sd">            weight_numel (int): Number of elements in the weight vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nn.Module: Initialized weight generator module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KAN</span><span class="p">([</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span> <span class="n">grid_size</span><span class="o">=</span><span class="n">GRID_SIZE</span><span class="p">,</span> <span class="n">grid_range</span><span class="o">=</span><span class="n">GRID_RANGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="MessagePackBlock.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.MessagePackBlock.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_feats_src</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> 
                <span class="n">node_feats_dst</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> 
                <span class="n">edge_feats</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> 
                <span class="n">local_env_edge</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                <span class="n">edge_scalars</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>

        <span class="c1"># Compute tensor products for node interaction</span>
        <span class="n">node_inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuse_node</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">node_feats_src</span><span class="p">,</span> <span class="n">node_feats_dst</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">weights_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weight_generator</span><span class="p">(</span><span class="n">edge_scalars</span><span class="p">)</span>
        <span class="n">node_inter_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_tensor_product</span><span class="p">(</span><span class="n">node_inter</span><span class="p">,</span> <span class="n">local_env_edge</span><span class="p">)</span>
        <span class="n">node_inter_dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_scaler</span><span class="p">(</span><span class="n">node_inter_up</span><span class="p">,</span> <span class="n">weights_node</span><span class="p">)</span>
        
        <span class="c1"># Compute tensor products for edge_features</span>
        <span class="n">weights_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_weight_generator</span><span class="p">(</span><span class="n">edge_scalars</span><span class="p">)</span>
        <span class="n">edge_feats_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_tensor_product</span><span class="p">(</span><span class="n">edge_feats</span><span class="p">,</span> <span class="n">local_env_edge</span><span class="p">)</span>
        <span class="n">edge_feats_dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_scaler</span><span class="p">(</span><span class="n">edge_feats_up</span><span class="p">,</span> <span class="n">weights_edge</span><span class="p">)</span>        

        <span class="c1"># output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_out</span><span class="p">(</span><span class="n">node_inter_dn</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_out</span><span class="p">(</span><span class="n">edge_feats_dn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>
</div>


<div class="viewcode-block" id="MessagePackBlockV2">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.MessagePackBlockV2">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MessagePackBlockV2</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_node_feats</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_edge_feats</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_local_env_edge</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_out</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">irreps_edge_scalars</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">radial_MLP</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
        <span class="n">use_kan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the MessagePackBlock.</span>

<span class="sd">        Args:</span>
<span class="sd">            irreps_node_feats (str): Irreducible representations for node features.</span>
<span class="sd">            irreps_edge_feats (str): Irreducible representations for edge features.</span>
<span class="sd">            irreps_local_env_edge (str): Irreducible representations for local environment edges.</span>
<span class="sd">            irreps_out (str): Irreducible representations for outputs.</span>
<span class="sd">            irreps_edge_scalars (str): Irreducible representations for edge scalars.</span>
<span class="sd">            radial_mlp_layers (List[int]): Layers for radial MLP.</span>
<span class="sd">            use_kan (bool): Flag to use KAN for weight generation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_local_env_edge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_scalars</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_scalars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">combined_node_irreps</span> <span class="o">=</span> <span class="n">scale_irreps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fuse_node</span> <span class="o">=</span> <span class="n">AttentionHeadsToVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">)</span>

        <span class="c1"># Calculate intermediate irreps and instructions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_node_irreps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_instructions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tp_out_irreps_with_instructions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_node_irreps</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_edge_irreps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_instructions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tp_out_irreps_with_instructions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_node_node_irreps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_node_instructions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tp_out_irreps_with_instructions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;uvu&#39;</span>
        <span class="p">)</span>

        <span class="c1"># Initialize tensor product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combined_node_irreps</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_node_irreps</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_local_env_edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_edge_irreps</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_node_tensor_product</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_node_node_irreps</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_node_instructions</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Initialize linear scaling with weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_scaler</span> <span class="o">=</span> <span class="n">LinearScaleWithWeights</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_node_irreps</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_scaler</span> <span class="o">=</span> <span class="n">LinearScaleWithWeights</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_edge_irreps</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_node_linear_scaler</span> <span class="o">=</span> <span class="n">LinearScaleWithWeights</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mid_node_node_irreps</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span>
        <span class="p">)</span>

        <span class="c1"># Initialize the weight generator</span>
        <span class="n">input_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_scalars</span><span class="o">.</span><span class="n">num_irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_scaler</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_scaler</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_node_weight_generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_weight_generator</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_node_linear_scaler</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">)</span>

        <span class="c1"># Linear output layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_node_linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tp_out_irreps_with_instructions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">irreps1</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">irreps2</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">target_irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;uvw&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
        <span class="n">trainable</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Collect possible irreps and their instructions</span>
        <span class="n">irreps_out_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">mul_i</span><span class="p">,</span> <span class="n">ir_in</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">mul_j</span><span class="p">,</span> <span class="n">ir_edge</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irreps2</span><span class="p">):</span>  
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_irreps</span><span class="p">):</span>                  
                    <span class="k">if</span> <span class="n">ir_out</span> <span class="ow">in</span> <span class="n">ir_in</span> <span class="o">*</span> <span class="n">ir_edge</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;uvw&#39;</span><span class="p">:</span>
                            <span class="n">irreps_out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;uvu&#39;</span><span class="p">:</span>
                            <span class="n">irreps_out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mul_i</span><span class="p">,</span> <span class="n">ir_out</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                        <span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">trainable</span><span class="p">))</span>

        <span class="c1"># We sort the output irreps of the tensor product so that we can simplify them</span>
        <span class="c1"># when they are provided to the second o3.Linear</span>
        <span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out_list</span><span class="p">)</span>
        <span class="n">irreps_out</span><span class="p">,</span> <span class="n">permut</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">irreps_out</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Permute the output indexes of the instructions to match the sorted irreps:</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">permut</span><span class="p">[</span><span class="n">i_out</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">train</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_in1</span><span class="p">,</span> <span class="n">i_in2</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">train</span> <span class="ow">in</span> <span class="n">instructions</span>
        <span class="p">]</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">instructions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_weight_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">weight_numel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the weight generator module.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_dim (int): Input dimension size for the weight generator.</span>
<span class="sd">            weight_numel (int): Number of elements in the weight vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nn.Module: Initialized weight generator module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KAN</span><span class="p">([</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span> <span class="n">grid_size</span><span class="o">=</span><span class="n">GRID_SIZE</span><span class="p">,</span> <span class="n">grid_range</span><span class="o">=</span><span class="n">GRID_RANGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="MessagePackBlockV2.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.MessagePackBlockV2.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_feats_src</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> 
                <span class="n">node_feats_dst</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> 
                <span class="n">edge_feats</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> 
                <span class="n">local_env_edge</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                <span class="n">edge_scalars</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>

        <span class="c1"># Compute tensor products for node interaction</span>
        <span class="n">node_inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuse_node</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">node_feats_src</span><span class="p">,</span> <span class="n">node_feats_dst</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">weights_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_weight_generator</span><span class="p">(</span><span class="n">edge_scalars</span><span class="p">)</span>
        <span class="n">node_inter_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_tensor_product</span><span class="p">(</span><span class="n">node_inter</span><span class="p">,</span> <span class="n">local_env_edge</span><span class="p">)</span>
        <span class="n">node_inter_dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_scaler</span><span class="p">(</span><span class="n">node_inter_up</span><span class="p">,</span> <span class="n">weights_node</span><span class="p">)</span>
        
        <span class="c1"># node-node tensor product</span>
        <span class="n">weights_node_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_node_weight_generator</span><span class="p">(</span><span class="n">edge_scalars</span><span class="p">)</span>
        <span class="n">node_node_inter_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_node_tensor_product</span><span class="p">(</span><span class="n">node_feats_dst</span><span class="p">,</span> <span class="n">node_feats_src</span><span class="p">)</span>
        <span class="n">node_node_inter_dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_node_linear_scaler</span><span class="p">(</span><span class="n">node_node_inter_up</span><span class="p">,</span> <span class="n">weights_node_node</span><span class="p">)</span>
        
        <span class="c1"># Compute tensor products for edge_features</span>
        <span class="n">weights_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_weight_generator</span><span class="p">(</span><span class="n">edge_scalars</span><span class="p">)</span>
        <span class="n">edge_feats_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_tensor_product</span><span class="p">(</span><span class="n">edge_feats</span><span class="p">,</span> <span class="n">local_env_edge</span><span class="p">)</span>
        <span class="n">edge_feats_dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_scaler</span><span class="p">(</span><span class="n">edge_feats_up</span><span class="p">,</span> <span class="n">weights_edge</span><span class="p">)</span>        

        <span class="c1"># output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_linear_out</span><span class="p">(</span><span class="n">node_inter_dn</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_linear_out</span><span class="p">(</span><span class="n">edge_feats_dn</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_node_linear_out</span><span class="p">(</span><span class="n">node_node_inter_dn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>
</div>


<span class="n">acts</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span>
    <span class="s2">&quot;tanh&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">,</span>
    <span class="s2">&quot;ssp&quot;</span><span class="p">:</span> <span class="n">ShiftedSoftPlus</span><span class="p">,</span>
    <span class="s2">&quot;silu&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
<span class="p">}</span>

<div class="viewcode-block" id="irreps2gate">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.irreps2gate">[文档]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">irreps2gate</span><span class="p">(</span>
    <span class="n">irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
    <span class="n">nonlinearity_scalars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;tanh&quot;</span><span class="p">},</span>
    <span class="n">nonlinearity_gates</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits irreducible representations into scalar and gated components and associates activation functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps (o3.Irreps): The input irreducible representations.</span>
<span class="sd">    - nonlinearity_scalars (Dict[int, str]): Activation functions for scalar components.</span>
<span class="sd">    - nonlinearity_gates (Dict[int, str]): Activation functions for gate components.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - Tuple containing:</span>
<span class="sd">        - irreps_scalars (o3.Irreps): Scalar irreps.</span>
<span class="sd">        - irreps_gates (o3.Irreps): Gate irreps.</span>
<span class="sd">        - irreps_gated (o3.Irreps): Gated irreps.</span>
<span class="sd">        - act_scalars (List[Callable]): Activation functions for scalars.</span>
<span class="sd">        - act_gates (List[Callable]): Activation functions for gates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Split the irreps into scalar and gated components</span>
    <span class="n">irreps_scalars</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir</span><span class="p">)</span> <span class="k">for</span> <span class="n">mul</span><span class="p">,</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">irreps</span> <span class="k">if</span> <span class="n">ir</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
    <span class="n">irreps_gated</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="n">mul</span><span class="p">,</span> <span class="n">ir</span><span class="p">)</span> <span class="k">for</span> <span class="n">mul</span><span class="p">,</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">irreps</span> <span class="k">if</span> <span class="n">ir</span><span class="o">.</span><span class="n">l</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

    <span class="c1"># Determine the gate irreps based on the presence of gated components</span>
    <span class="n">irreps_gates</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;0e&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">mul</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">irreps_gated</span><span class="p">])</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="k">if</span> <span class="n">irreps_gated</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([])</span>

    <span class="c1"># Retrieve the activation functions for scalars and gates</span>
    <span class="n">act_scalars</span> <span class="o">=</span> <span class="p">[</span><span class="n">acts</span><span class="p">[</span><span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">p</span><span class="p">]]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">irreps_scalars</span><span class="p">]</span>
    <span class="n">act_gates</span> <span class="o">=</span> <span class="p">[</span><span class="n">acts</span><span class="p">[</span><span class="n">nonlinearity_gates</span><span class="p">[</span><span class="n">ir</span><span class="o">.</span><span class="n">p</span><span class="p">]]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">irreps_gates</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">irreps_scalars</span><span class="p">,</span> <span class="n">irreps_gates</span><span class="p">,</span> <span class="n">irreps_gated</span><span class="p">,</span> <span class="n">act_scalars</span><span class="p">,</span> <span class="n">act_gates</span></div>


<div class="viewcode-block" id="scale_irreps">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.scale_irreps">[文档]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">scale_irreps</span><span class="p">(</span><span class="n">irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scales the multiplicities of the irreducible representations (irreps) by a given factor,</span>
<span class="sd">    ensuring they remain at least 1.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps (o3.Irreps): The input irreps.</span>
<span class="sd">    - factor (float): The scaling factor.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - o3.Irreps: The scaled irreps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">mul</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)),</span> <span class="n">ir</span><span class="p">)</span> <span class="k">for</span> <span class="n">mul</span><span class="p">,</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">irreps</span><span class="p">])</span></div>


<div class="viewcode-block" id="filter_and_split_irreps">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.filter_and_split_irreps">[文档]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_and_split_irreps</span><span class="p">(</span><span class="n">irreps</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">min_l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_l</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters and splits irreducible representations (irreps) based on specified angular momentum range.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps (o3.Irreps): The input irreducible representations.</span>
<span class="sd">    - num_channels (int): The number of channels to split the multiplicity by.</span>
<span class="sd">    - min_l (int): The minimum angular momentum (inclusive).</span>
<span class="sd">    - max_l (int): The maximum angular momentum (inclusive).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - o3.Irreps: The resulting irreducible representations after filtering and splitting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_irreps</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="n">irreps</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">irrep</span><span class="o">.</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">min_l</span> <span class="ow">or</span> <span class="n">irrep</span><span class="o">.</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">max_l</span><span class="p">:</span>
            <span class="c1"># Retain irreps outside the specified l range</span>
            <span class="n">result_irreps</span> <span class="o">+=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="n">multiplicity</span><span class="p">,</span> <span class="n">irrep</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Split multiplicity by num_channels for irreps within the range</span>
            <span class="n">split_multiplicity</span> <span class="o">=</span> <span class="n">multiplicity</span> <span class="o">//</span> <span class="n">num_channels</span>
            <span class="k">if</span> <span class="n">split_multiplicity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result_irreps</span> <span class="o">+=</span> <span class="n">split_multiplicity</span> <span class="o">*</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">irrep</span><span class="p">)])</span>
    
    <span class="k">return</span> <span class="n">result_irreps</span></div>


<div class="viewcode-block" id="RadialBasisEdgeEncoding">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.RadialBasisEdgeEncoding">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RadialBasisEdgeEncoding</span><span class="p">(</span><span class="n">GraphModuleMixin</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encodes edge lengths using a specified radial basis.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        out_field (str): The key for storing the encoded edge features.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">out_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">,</span>
        <span class="n">irreps_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the RadialBasisEdgeEncoding module.</span>

<span class="sd">        :param basis: The radial basis function used for encoding.</span>
<span class="sd">        :param out_field: The output field key for encoded edges.</span>
<span class="sd">        :param irreps_in: Input irreducible representations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_field</span> <span class="o">=</span> <span class="n">out_field</span>

        <span class="c1"># Determine the number of basis functions based on the basis type</span>
        <span class="n">basis_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">basis_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;BesselBasis&#39;</span><span class="p">,</span> <span class="s1">&#39;GaussianSmearing&#39;</span><span class="p">}:</span>
            <span class="n">num_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">freqs</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">basis_type</span> <span class="o">==</span> <span class="s1">&#39;BesselBasis&#39;</span> <span class="k">else</span> <span class="n">basis</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">basis_type</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s1">&#39;ExponentialGaussianRadialBasisFunctions&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ExponentialBernsteinRadialBasisFunctions&#39;</span><span class="p">,</span>
            <span class="s1">&#39;GaussianRadialBasisFunctions&#39;</span><span class="p">,</span>
            <span class="s1">&#39;BernsteinRadialBasisFunctions&#39;</span>
        <span class="p">}:</span>
            <span class="n">num_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">num_basis_functions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Basis type </span><span class="si">{</span><span class="n">basis_type</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_irreps</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">out_field</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="n">num_basis</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])},</span>
        <span class="p">)</span>

<div class="viewcode-block" id="RadialBasisEdgeEncoding.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.RadialBasisEdgeEncoding.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the edge encoding and updates the data dictionary.</span>

<span class="sd">        :param data: A dictionary containing graph data.</span>
<span class="sd">        :return: Updated graph data with encoded edge features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">edge_index</span>
        <span class="n">nbr_shift</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">nbr_shift</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pos</span>

        <span class="c1"># Calculate edge directions and lengths</span>
        <span class="n">edge_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nbr_shift</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">edge_length</span> <span class="o">=</span> <span class="n">edge_dir</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Update data with computed edge vectors and lengths</span>
        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_VECTORS_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_dir</span><span class="o">/</span><span class="n">edge_length</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_LENGTH_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_length</span>

        <span class="c1"># Apply the radial basis to the edge lengths</span>
        <span class="n">edge_length_embedded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">edge_length</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_length_embedded</span> <span class="o">=</span> <span class="n">edge_length_embedded</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">(</span><span class="n">edge_length</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
            
        <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">out_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_length_embedded</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>


<div class="viewcode-block" id="VectorToAttentionHeads">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.VectorToAttentionHeads">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VectorToAttentionHeads</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reshapes vectors of shape [N, irreps_mid] to vectors of shape [N, num_heads, irreps_head].</span>

<span class="sd">    Attributes:</span>
<span class="sd">    - num_heads (int): Number of attention heads.</span>
<span class="sd">    - irreps_head (o3.Irreps): Irreps of each head.</span>
<span class="sd">    - irreps_mid_in (o3.Irreps): Intermediate irreps.</span>
<span class="sd">    - mid_in_indices (List[Tuple[int, int]]): Indices for reshaping.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_head</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span> <span class="o">=</span> <span class="n">num_heads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_head</span> <span class="o">=</span> <span class="n">irreps_head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid_in</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">([(</span><span class="n">mul</span> <span class="o">*</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">ir</span><span class="p">)</span> <span class="k">for</span> <span class="n">mul</span><span class="p">,</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">irreps_head</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_in_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">mul</span><span class="p">,</span> <span class="n">ir</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_mid_in</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mid_in_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">mul</span> <span class="o">*</span> <span class="n">ir</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">mul</span> <span class="o">*</span> <span class="n">ir</span><span class="o">.</span><span class="n">dim</span>

<div class="viewcode-block" id="VectorToAttentionHeads.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.VectorToAttentionHeads.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">reshaped_tensors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x</span><span class="o">.</span><span class="n">narrow</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="n">start_idx</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mid_in_indices</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">reshaped_tensors</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(irreps_head=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_head</span><span class="si">}</span><span class="s1">, num_heads=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="si">}</span><span class="s1">)&#39;</span></div>


<div class="viewcode-block" id="AttentionHeadsToVector">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionHeadsToVector">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AttentionHeadsToVector</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts vectors of shape [N, num_heads, irreps_head] into vectors of shape [N, irreps_head * num_heads].</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        irreps_head (o3.Irreps): A list of irreducible representations (irreps) that define</span>
<span class="sd">                                 the structure of the attention heads.</span>
<span class="sd">        head_sizes (List[int]): A list of sizes for each attention head, derived from the irreps.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_head</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the AttentionHeadsToVector module.</span>

<span class="sd">        Args:</span>
<span class="sd">            irreps_head (o3.Irreps): A list of irreducible representations (irreps) used to define</span>
<span class="sd">                                     the structure of attention heads. Each irrep specifies the</span>
<span class="sd">                                     multiplicity and dimension of a representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_head</span> <span class="o">=</span> <span class="n">irreps_head</span>

        <span class="c1"># Compute the size of each attention head based on the irreps definitions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">multiplicity</span> <span class="o">*</span> <span class="n">irrep</span><span class="o">.</span><span class="n">dim</span> <span class="k">for</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_head</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide a string representation of the module for debugging.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A string representation of the AttentionHeadProcessor instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(irreps_head=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_head</span><span class="si">}</span><span class="s1">)&#39;</span>

<div class="viewcode-block" id="AttentionHeadsToVector.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionHeadsToVector.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass to process the attention heads and flatten them into a single vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor of shape (N, num_heads, input_dim), where:</span>
<span class="sd">                - N is the batch size.</span>
<span class="sd">                - num_heads is the number of attention heads.</span>
<span class="sd">                - input_dim is the total size of all heads.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor of shape (N, flattened_dim), where `flattened_dim`</span>
<span class="sd">                          is the sum of the dimensions of all attention heads.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the sum of `head_sizes` does not match `input_dim` of the input tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the dimensions of the input tensor.</span>
        <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">input_dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Ensure the total size of all attention heads matches the input tensor&#39;s last dimension.</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_sizes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">input_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The sum of head_sizes (</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_sizes</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match the input_dim (</span><span class="si">{</span><span class="n">input_dim</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="s2">&quot;of the input tensor.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Split the input tensor along the last dimension based on head_sizes.</span>
        <span class="n">split_tensors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_sizes</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Reshape each split tensor to flatten the attention heads into a single vector per batch.</span>
        <span class="c1"># Use `contiguous()` to ensure the tensor&#39;s memory layout is consistent.</span>
        <span class="n">flattened_tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_tensor</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_tensor</span> <span class="ow">in</span> <span class="n">split_tensors</span><span class="p">]</span>

        <span class="c1"># Concatenate the flattened tensors along the last dimension to produce the output.</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">flattened_tensors</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="ConvBlockE3">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ConvBlockE3">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ConvBlockE3</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An equivariant convolutional block for processing node features using tensor products</span>
<span class="sd">    with optional skip connections.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps_in (o3.Irreps): Input irreducible representations.</span>
<span class="sd">    - irreps_out (o3.Irreps): Output irreducible representations.</span>
<span class="sd">    - irreps_edge_attrs (o3.Irreps): Edge attribute irreducible representations.</span>
<span class="sd">    - irreps_edge_embed (o3.Irreps): Edge embedding irreducible representations.</span>
<span class="sd">    - radial_MLP (Optional[List[int]]): MLP architecture for radial embeddings. Defaults to [64, 64, 64].</span>
<span class="sd">    - use_skip_connections (bool): Whether to use skip connections. Defaults to True.</span>
<span class="sd">    - use_kan (bool): Whether to use the FastKAN module for weight generation. Defaults to False.</span>
<span class="sd">    - nonlinearity_type (str): Type of nonlinearity to use (&quot;gate&quot; or &quot;norm&quot;). Defaults to &quot;gate&quot;.</span>
<span class="sd">    - nonlinearity_scalars (Dict[int, Callable]): Nonlinearity for scalar channels.</span>
<span class="sd">    - nonlinearity_gates (Dict[int, Callable]): Nonlinearity for gate channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_in</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_out</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_node_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_embed</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">radial_MLP</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_skip_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_kan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nonlinearity_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gate&quot;</span><span class="p">,</span>
        <span class="n">nonlinearity_scalars</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;tanh&quot;</span><span class="p">},</span>
        <span class="n">nonlinearity_gates</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">},</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span> <span class="o">=</span> <span class="n">use_skip_connections</span>

        <span class="k">assert</span> <span class="n">nonlinearity_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gate&quot;</span><span class="p">,</span> <span class="s2">&quot;norm&quot;</span><span class="p">),</span> <span class="s2">&quot;Invalid nonlinearity type.&quot;</span>

        <span class="c1"># Convert nonlinearity mappings</span>
        <span class="n">scalar_nonlinearities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">gate_nonlinearities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_embed</span><span class="p">)</span>

        <span class="c1"># Residual block for processing features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="n">ResidualBlock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">)</span>

        <span class="c1"># Convolution layers       </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp</span> <span class="o">=</span> <span class="n">MessagePackBlock</span><span class="p">(</span>
            <span class="n">irreps_node_feats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">irreps_edge_feats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">irreps_local_env_edge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span><span class="p">,</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
            <span class="n">irreps_edge_scalars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span><span class="p">,</span> 
            <span class="n">radial_MLP</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span><span class="p">,</span> 
            <span class="n">use_kan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span>
            <span class="p">)</span>
        
        <span class="c1"># Skip connection layer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_linear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">)</span>

<div class="viewcode-block" id="ConvBlockE3.create_linear">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ConvBlockE3.create_linear">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a linear layer.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - irreps_in (o3.Irreps): Input irreps for the linear layer.</span>
<span class="sd">        - irreps_out (o3.Irreps, optional): Output irreps for the linear layer.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - o3.Linear: A linear transformation layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span> <span class="ow">or</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ConvBlockE3.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ConvBlockE3.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the convolutional block.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - data (dict): Dictionary containing graph data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - torch.Tensor: Updated node features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">]</span>
        <span class="n">node_features</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
        <span class="n">edge_embedding</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">]</span>
        <span class="n">edge_attributes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_ATTRS_KEY</span><span class="p">]</span>
        <span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">])</span>

        <span class="c1"># Skip connection</span>
        <span class="n">skip_connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_linear</span><span class="p">(</span><span class="n">node_features</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span> <span class="k">else</span> <span class="kc">None</span>
        
        <span class="c1"># Messages        </span>
        <span class="n">messages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp</span><span class="p">(</span>
            <span class="n">node_features</span><span class="p">[</span><span class="n">sender</span><span class="p">],</span> 
            <span class="n">node_features</span><span class="p">[</span><span class="n">receiver</span><span class="p">],</span>  
            <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_FEATURES_KEY</span><span class="p">],</span> 
            <span class="n">edge_attributes</span><span class="p">,</span>
            <span class="n">edge_embedding</span>
        <span class="p">)</span>

        <span class="c1"># Aggregate messages</span>
        <span class="n">aggregated_messages</span> <span class="o">=</span> <span class="n">scatter</span><span class="p">(</span>
            <span class="n">src</span><span class="o">=</span><span class="n">messages</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">receiver</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_size</span><span class="o">=</span><span class="n">num_nodes</span>
        <span class="p">)</span>
        
        <span class="c1"># Apply residual block</span>
        <span class="n">output_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual</span><span class="p">(</span><span class="n">aggregated_messages</span><span class="p">)</span>

        <span class="c1"># Apply skip connection if used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span><span class="p">:</span>
            <span class="n">output_features</span> <span class="o">+=</span> <span class="n">skip_connection</span>

        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_features</span>
        
        <span class="k">return</span> <span class="n">output_features</span></div>
</div>


<div class="viewcode-block" id="AttentionAggregationV2">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionAggregationV2">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AttentionAggregationV2</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An equivariant attention mechanism that processes key, value, and query vectors</span>
<span class="sd">    and applies attention across edges in a graph.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - num_heads (int): Number of attention heads.</span>
<span class="sd">    - irreps_value (o3.Irreps): Irreducible representations for value vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">num_heads</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
        <span class="n">irreps_value</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> 
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span> <span class="o">=</span> <span class="n">num_heads</span>
        <span class="n">irreps_value</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_value</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">value_irreps_head</span> <span class="o">=</span> <span class="n">scale_irreps</span><span class="p">(</span><span class="n">irreps_value</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">num_heads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_value</span> <span class="o">=</span> <span class="n">VectorToAttentionHeads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_irreps_head</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fuse_value</span> <span class="o">=</span> <span class="n">AttentionHeadsToVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_irreps_head</span><span class="p">)</span>
    
<div class="viewcode-block" id="AttentionAggregationV2.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionAggregationV2.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">value</span><span class="p">,</span>
        <span class="n">edge_weights</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>  <span class="c1"># (num_edges, num_heads)</span>
        <span class="n">edge_weights_cutoff</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="c1"># (num_edges,)</span>
        <span class="n">edge_index</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the attention mechanism.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - key (torch.Tensor): Key vectors.</span>
<span class="sd">        - value (torch.Tensor): Value vectors.</span>
<span class="sd">        - query (torch.Tensor): Query vectors.</span>
<span class="sd">        - edge_weight_cutoff (torch.Tensor): Cutoff weights for edges.</span>
<span class="sd">        - edge_index (torch.LongTensor): Edge indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - torch.Tensor: Attended output vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        
        <span class="n">edge_src</span><span class="p">,</span> <span class="n">edge_dst</span> <span class="o">=</span> <span class="n">edge_index</span>
        
        <span class="c1"># Compute the attention weights per edge</span>
        <span class="k">if</span> <span class="n">edge_weights_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_weights_cutoff</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">edge_weights</span>  <span class="c1"># (num_edges, num_heads)</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_softmax</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">,</span> <span class="n">edge_dst</span><span class="p">)</span>  <span class="c1"># (num_edges, num_heads)</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_weights</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (num_edges, num_heads, 1)</span>

        <span class="c1"># Compute the attended outputs per node</span>
        <span class="n">f_out</span> <span class="o">=</span> <span class="n">scatter</span><span class="p">(</span><span class="n">edge_weights</span> <span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="n">edge_dst</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># (num_nodes, num_heads, irreps_head)</span>
        <span class="n">f_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuse_value</span><span class="p">(</span><span class="n">f_out</span><span class="p">)</span>  <span class="c1"># Merge heads</span>
        <span class="k">return</span> <span class="n">f_out</span></div>
</div>


<div class="viewcode-block" id="AttentionAggregation">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionAggregation">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AttentionAggregation</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An equivariant attention mechanism that processes key, value, and query vectors</span>
<span class="sd">    and applies attention across edges in a graph.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - num_heads (int): Number of attention heads.</span>
<span class="sd">    - irreps_key (o3.Irreps): Irreducible representations for key vectors.</span>
<span class="sd">    - irreps_value (o3.Irreps): Irreducible representations for value vectors.</span>
<span class="sd">    - irreps_query (o3.Irreps): Irreducible representations for query vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">num_heads</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
        <span class="n">irreps_key</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> 
        <span class="n">irreps_value</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span> 
        <span class="n">irreps_query</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span> <span class="o">=</span> <span class="n">num_heads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_key</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_key</span><span class="p">)</span>
        <span class="n">irreps_value</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_value</span><span class="p">)</span>
        <span class="n">irreps_query</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_query</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">key_irreps_head</span> <span class="o">=</span> <span class="n">scale_irreps</span><span class="p">(</span><span class="n">irreps_key</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">num_heads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_irreps_head</span> <span class="o">=</span> <span class="n">scale_irreps</span><span class="p">(</span><span class="n">irreps_value</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">num_heads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_irreps_head</span> <span class="o">=</span> <span class="n">scale_irreps</span><span class="p">(</span><span class="n">irreps_query</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">num_heads</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_key</span> <span class="o">=</span> <span class="n">VectorToAttentionHeads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_irreps_head</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_value</span> <span class="o">=</span> <span class="n">VectorToAttentionHeads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_irreps_head</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_query</span> <span class="o">=</span> <span class="n">VectorToAttentionHeads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_irreps_head</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">fuse_value</span> <span class="o">=</span> <span class="n">AttentionHeadsToVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_irreps_head</span><span class="p">)</span>
    
<div class="viewcode-block" id="AttentionAggregation.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionAggregation.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">key</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>  <span class="c1"># (num_edges, hidden_feat_len)</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="c1"># (num_edges, hidden_feat_len) </span>
        <span class="n">query</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>  <span class="c1"># (num_edges, hidden_feat_len) </span>
        <span class="n">edge_weight_cutoff</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="c1"># (num_edges,)</span>
        <span class="n">edge_index</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the attention mechanism.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - key (torch.Tensor): Key vectors.</span>
<span class="sd">        - value (torch.Tensor): Value vectors.</span>
<span class="sd">        - query (torch.Tensor): Query vectors.</span>
<span class="sd">        - edge_weight_cutoff (torch.Tensor): Cutoff weights for edges.</span>
<span class="sd">        - edge_index (torch.LongTensor): Edge indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - torch.Tensor: Attended output vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfuse_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        
        <span class="n">edge_src</span><span class="p">,</span> <span class="n">edge_dst</span> <span class="o">=</span> <span class="n">edge_index</span>
        
        <span class="c1"># Compute the attention weights per edge</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">query</span> <span class="o">*</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (num_edges, num_heads)</span>
        <span class="k">if</span> <span class="n">edge_weight_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_weight_cutoff</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">edge_weights</span>  <span class="c1"># (num_edges, num_heads)</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_weights</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_irreps_head</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_softmax</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">,</span> <span class="n">edge_dst</span><span class="p">)</span>  <span class="c1"># (num_edges, num_heads)</span>
        <span class="n">edge_weights</span> <span class="o">=</span> <span class="n">edge_weights</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (num_edges, num_heads, 1)</span>

        <span class="c1"># Compute the attended outputs per node</span>
        <span class="n">f_out</span> <span class="o">=</span> <span class="n">scatter</span><span class="p">(</span><span class="n">edge_weights</span> <span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="n">edge_dst</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># (num_nodes, num_heads, irreps_head)</span>
        <span class="n">f_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuse_value</span><span class="p">(</span><span class="n">f_out</span><span class="p">)</span>  <span class="c1"># Merge heads</span>
        <span class="k">return</span> <span class="n">f_out</span></div>
</div>


<div class="viewcode-block" id="AttentionBlockE3">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionBlockE3">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>    
<span class="k">class</span><span class="w"> </span><span class="nc">AttentionBlockE3</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An equivariant attention block for processing graph data with attention mechanisms.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - irreps_in (o3.Irreps): Input irreducible representations.</span>
<span class="sd">    - irreps_out (o3.Irreps): Output irreducible representations.</span>
<span class="sd">    - irreps_node_attrs (o3.Irreps): Node attribute irreducible representations.</span>
<span class="sd">    - irreps_edge_attrs (o3.Irreps): Edge attribute irreducible representations.</span>
<span class="sd">    - irreps_edge_embed (o3.Irreps): Edge embedding irreducible representations.</span>
<span class="sd">    - num_heads (int): Number of attention heads.</span>
<span class="sd">    - max_radius (float): Maximum radius for edge cutoff.</span>
<span class="sd">    - radial_MLP (Optional[List[int]]): Architecture of the radial MLP.</span>
<span class="sd">    - use_skip_connections (bool): Whether to use skip connections.</span>
<span class="sd">    - use_kan (bool): Whether to use KAN for radial MLP.</span>
<span class="sd">    - nonlinearity_type (str): Type of nonlinearity (&#39;gate&#39; or &#39;norm&#39;).</span>
<span class="sd">    - nonlinearity_scalars (Dict[int, Callable]): Scalar nonlinearity functions.</span>
<span class="sd">    - nonlinearity_gates (Dict[int, Callable]): Gate nonlinearity functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_in</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_out</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_node_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_feats</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_embed</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">num_heads</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">max_radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">radial_MLP</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_skip_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_kan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nonlinearity_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gate&quot;</span><span class="p">,</span>
        <span class="n">nonlinearity_scalars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;tanh&quot;</span><span class="p">},</span>
        <span class="n">nonlinearity_gates</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">},</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span> <span class="o">=</span> <span class="n">use_skip_connections</span>

        <span class="k">assert</span> <span class="n">nonlinearity_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gate&quot;</span><span class="p">,</span> <span class="s2">&quot;norm&quot;</span><span class="p">),</span> <span class="s2">&quot;Invalid nonlinearity type.&quot;</span>

        <span class="c1"># Convert nonlinearity mappings</span>
        <span class="n">nonlinearity_scalars</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">nonlinearity_gates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="c1"># Assign irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_out</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_embed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_feats</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_attrs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span>
            <span class="s2">&quot;max_radius&quot;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">max_radius</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">get_default_dtype</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_func</span> <span class="o">=</span> <span class="n">SoftUnitStepCutoff</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">max_radius</span><span class="p">)</span>
        
        <span class="c1"># Linear transformations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_tar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">)</span>

        <span class="c1"># Nonlinearity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="n">ResidualBlock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">)</span>

        <span class="c1"># Create TensorProducts for value        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp_value</span> <span class="o">=</span> <span class="n">MessagePackBlock</span><span class="p">(</span><span class="n">irreps_node_feats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
                                            <span class="n">irreps_edge_feats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span>
                                            <span class="n">irreps_local_env_edge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span><span class="p">,</span>
                                            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span>
                                            <span class="n">irreps_edge_scalars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span><span class="p">,</span>
                                            <span class="n">radial_MLP</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span><span class="p">,</span>
                                            <span class="n">use_kan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">)</span>
        
        <span class="c1"># Linear layers for key, query, and value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">)</span>

        <span class="c1"># Attention mechanism</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attention</span> <span class="o">=</span> <span class="n">AttentionAggregation</span><span class="p">(</span>
            <span class="n">num_heads</span><span class="o">=</span><span class="n">num_heads</span><span class="p">,</span>
            <span class="n">irreps_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">irreps_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">irreps_query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="c1"># Skip connection</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_linear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">)</span>

<div class="viewcode-block" id="AttentionBlockE3.create_linear">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionBlockE3.create_linear">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a linear layer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span> <span class="ow">or</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AttentionBlockE3.create_tensor_product">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionBlockE3.create_tensor_product">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_tensor_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_mid</span><span class="p">,</span> <span class="n">instructions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a TensorProduct layer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span><span class="p">,</span>
            <span class="n">irreps_mid</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AttentionBlockE3.init_weight_generator">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionBlockE3.init_weight_generator">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_weight_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">weight_numel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize weight generator.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KAN</span><span class="p">([</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span> <span class="n">grid_size</span><span class="o">=</span><span class="n">GRID_SIZE</span><span class="p">,</span> <span class="n">grid_range</span><span class="o">=</span><span class="n">GRID_RANGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AttentionBlockE3.create_nonlinearity">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionBlockE3.create_nonlinearity">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_nonlinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonlinearity_type</span><span class="p">,</span> <span class="n">nonlinearity_scalars</span><span class="p">,</span> <span class="n">nonlinearity_gates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create nonlinearity module.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nonlinearity_type</span> <span class="o">==</span> <span class="s2">&quot;gate&quot;</span><span class="p">:</span>
            <span class="n">irreps_scalars</span><span class="p">,</span> <span class="n">irreps_gates</span><span class="p">,</span> <span class="n">irreps_gated</span><span class="p">,</span> <span class="n">act_scalars</span><span class="p">,</span> <span class="n">act_gates</span> <span class="o">=</span> <span class="n">irreps2gate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="n">nonlinearity_scalars</span><span class="p">,</span> <span class="n">nonlinearity_gates</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Gate</span><span class="p">(</span>
                <span class="n">irreps_scalars</span><span class="o">=</span><span class="n">irreps_scalars</span><span class="p">,</span>
                <span class="n">act_scalars</span><span class="o">=</span><span class="n">act_scalars</span><span class="p">,</span>
                <span class="n">irreps_gates</span><span class="o">=</span><span class="n">irreps_gates</span><span class="p">,</span>
                <span class="n">act_gates</span><span class="o">=</span><span class="n">act_gates</span><span class="p">,</span>
                <span class="n">irreps_gated</span><span class="o">=</span><span class="n">irreps_gated</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">NormActivation</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span>
            <span class="n">scalar_nonlinearity</span><span class="o">=</span><span class="n">acts</span><span class="p">[</span><span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
            <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AttentionBlockE3.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.AttentionBlockE3.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the attention block.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - data (Dict[str, torch.Tensor]): A dictionary containing the graph data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - Tuple[torch.Tensor, Optional[torch.Tensor]]: Updated node features and skip connection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">]</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
        <span class="n">edge_embed</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">]</span>
        <span class="n">edge_attrs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_ATTRS_KEY</span><span class="p">]</span>
        <span class="n">edge_feats</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_FEATURES_KEY</span><span class="p">]</span>
        
        <span class="c1"># Skip connection</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_linear</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Process key, query, and value</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_key</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)[</span><span class="n">sender</span><span class="p">]</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_key</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)[</span><span class="n">receiver</span><span class="p">]</span>
        
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear_up_src</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)[</span><span class="n">sender</span><span class="p">],</span> 
                                   <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_tar</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)[</span><span class="n">receiver</span><span class="p">],</span>  
                                   <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_edge</span><span class="p">(</span><span class="n">edge_feats</span><span class="p">),</span>
                                   <span class="n">edge_attrs</span><span class="p">,</span> 
                                   <span class="n">edge_embed</span><span class="p">)</span>

        <span class="c1"># Attention mechanism      </span>
        <span class="n">edge_weight_cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_func</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_LENGTH_KEY</span><span class="p">])</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">edge_weight_cutoff</span><span class="p">,</span> <span class="n">edge_index</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">])</span>

        <span class="c1"># Apply nonlinearity</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)</span>

        <span class="c1"># Apply skip connection if used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span><span class="p">:</span>
            <span class="n">node_feats</span> <span class="o">+=</span> <span class="n">sc</span>  

        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_feats</span>

        <span class="k">return</span> <span class="n">node_feats</span></div>
</div>


<div class="viewcode-block" id="PairInteractionEmbeddingBlock">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionEmbeddingBlock">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PairInteractionEmbeddingBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A pair interaction block for updating edge features based on node features and edge attributes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps_node_feats (o3.Irreps): Irreducible representations for node features.</span>
<span class="sd">    - irreps_edge_attrs (o3.Irreps): Irreducible representations for edge attributes.</span>
<span class="sd">    - irreps_edge_embed (o3.Irreps): Irreducible representations for edge embeddings.</span>
<span class="sd">    - irreps_edge_feats (o3.Irreps): Irreducible representations for edge features.</span>
<span class="sd">    - use_skip_connections (bool): Whether to use skip connections.</span>
<span class="sd">    - use_kan (bool): Whether to use KAN for radial MLP.</span>
<span class="sd">    - radial_MLP (Optional[List[int]]): Architecture of the radial MLP.</span>
<span class="sd">    - nonlinearity_type (str): Type of nonlinearity to use (&quot;gate&quot; or &quot;norm&quot;).</span>
<span class="sd">    - nonlinearity_scalars (Dict[int, Callable]): Nonlinearity for scalar channels.</span>
<span class="sd">    - nonlinearity_gates (Dict[int, Callable]): Nonlinearity for gate channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_node_feats</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_node_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_embed</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_feats</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">use_kan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">radial_MLP</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nonlinearity_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gate&quot;</span><span class="p">,</span>
        <span class="n">nonlinearity_scalars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;tanh&quot;</span><span class="p">},</span>
        <span class="n">nonlinearity_gates</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>

        <span class="c1"># Assign irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_embed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_attrs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">nonlinearity_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gate&quot;</span><span class="p">,</span> <span class="s2">&quot;norm&quot;</span><span class="p">),</span> <span class="s2">&quot;Invalid nonlinearity type.&quot;</span>

        <span class="c1"># Convert nonlinearity mappings</span>
        <span class="n">nonlinearity_scalars</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">nonlinearity_gates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="c1"># Linear layers for lifting node features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_dst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">)</span>

        <span class="c1"># TensorProduct layer for edge feature mixing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp</span> <span class="o">=</span> <span class="n">TensorProductWithMemoryOptimizationWithWeight</span><span class="p">(</span><span class="n">irreps_input_1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span> 
                                                                      <span class="n">irreps_input_2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span><span class="p">,</span> 
                                                                      <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span> 
                                                                      <span class="n">irreps_scalar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span><span class="p">,</span> 
                                                                      <span class="n">radial_MLP</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span><span class="p">,</span> 
                                                                      <span class="n">use_kan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">)</span>

<div class="viewcode-block" id="PairInteractionEmbeddingBlock.create_linear">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionEmbeddingBlock.create_linear">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a linear layer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span> <span class="ow">or</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PairInteractionEmbeddingBlock.create_tensor_product">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionEmbeddingBlock.create_tensor_product">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_tensor_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_mid</span><span class="p">,</span> <span class="n">instructions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a TensorProduct layer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">TensorProduct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span><span class="p">,</span>
            <span class="n">irreps_mid</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PairInteractionEmbeddingBlock.init_weight_generator">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionEmbeddingBlock.init_weight_generator">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_weight_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">weight_numel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize weight generator.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KAN</span><span class="p">([</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span> <span class="n">grid_size</span><span class="o">=</span><span class="n">GRID_SIZE</span><span class="p">,</span> <span class="n">grid_range</span><span class="o">=</span><span class="n">GRID_RANGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">input_dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">+</span> <span class="p">[</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PairInteractionEmbeddingBlock.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionEmbeddingBlock.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the pair interaction block.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - data (Dict[str, torch.Tensor]): A dictionary containing the graph data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - torch.Tensor: Updated edge features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_src</span><span class="p">,</span> <span class="n">edge_dst</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">]</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
        <span class="n">edge_embed</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">]</span>
        <span class="n">edge_attributes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_ATTRS_KEY</span><span class="p">]</span>
        
        <span class="n">node_feats_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_src</span><span class="p">(</span><span class="n">node_feats</span><span class="p">[</span><span class="n">edge_src</span><span class="p">])</span>
        <span class="n">node_feats_dst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_dst</span><span class="p">(</span><span class="n">node_feats</span><span class="p">[</span><span class="n">edge_dst</span><span class="p">])</span>

        <span class="c1"># Mixing node features for edge features</span>
        <span class="n">edge_feats_mix_tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp</span><span class="p">(</span>
            <span class="n">node_feats_src</span> <span class="o">+</span> <span class="n">node_feats_dst</span><span class="p">,</span> <span class="n">edge_attributes</span><span class="p">,</span> <span class="n">edge_embed</span>
        <span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_feats_mix_tp</span>
        <span class="k">return</span> <span class="n">edge_feats_mix_tp</span></div>
</div>


<div class="viewcode-block" id="PairInteractionBlock">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionBlock">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PairInteractionBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A pair interaction block for updating edge features based on node features and edge attributes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps_node_feats (o3.Irreps): Irreducible representations for node features.</span>
<span class="sd">    - irreps_edge_attrs (o3.Irreps): Irreducible representations for edge attributes.</span>
<span class="sd">    - irreps_edge_embed (o3.Irreps): Irreducible representations for edge embeddings.</span>
<span class="sd">    - irreps_edge_feats (o3.Irreps): Irreducible representations for edge features.</span>
<span class="sd">    - use_skip_connections (bool): Whether to use skip connections.</span>
<span class="sd">    - use_kan (bool): Whether to use KAN for radial MLP.</span>
<span class="sd">    - radial_MLP (Optional[List[int]]): Architecture of the radial MLP. Defaults to [64, 64, 64].</span>
<span class="sd">    - nonlinearity_type (str): Type of nonlinearity to use (&quot;gate&quot; or &quot;norm&quot;).</span>
<span class="sd">    - nonlinearity_scalars (Dict[int, Callable]): Nonlinearity for scalar channels.</span>
<span class="sd">    - nonlinearity_gates (Dict[int, Callable]): Nonlinearity for gate channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_node_feats</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_node_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_attrs</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_embed</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">irreps_edge_feats</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">use_skip_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_kan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">radial_MLP</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nonlinearity_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gate&quot;</span><span class="p">,</span>
        <span class="n">nonlinearity_scalars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;tanh&quot;</span><span class="p">},</span>
        <span class="n">nonlinearity_gates</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span> <span class="o">=</span> <span class="n">radial_MLP</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span> <span class="o">=</span> <span class="n">use_skip_connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span> <span class="o">=</span> <span class="n">use_kan</span>

        <span class="c1"># Assign irreps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_embed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_edge_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_attrs</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_attrs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">nonlinearity_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gate&quot;</span><span class="p">,</span> <span class="s2">&quot;norm&quot;</span><span class="p">),</span> <span class="s2">&quot;Invalid nonlinearity type.&quot;</span>

        <span class="c1"># Convert nonlinearity mappings</span>
        <span class="n">scalar_nonlinearities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">gate_nonlinearities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="c1"># Linear transformations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_tar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">)</span>

        <span class="c1"># TensorProduct layer for edge feature mixing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp</span> <span class="o">=</span> <span class="n">MessagePackBlock</span><span class="p">(</span>
            <span class="n">irreps_node_feats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="n">irreps_edge_feats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span>
            <span class="n">irreps_local_env_edge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_attrs</span><span class="p">,</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_feats</span><span class="p">,</span>
            <span class="n">irreps_edge_scalars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_edge_embed</span><span class="p">,</span> 
            <span class="n">radial_MLP</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radial_MLP</span><span class="p">,</span> 
            <span class="n">use_kan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_kan</span>
            <span class="p">)</span>

        <span class="c1"># Skip connection</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skip_linear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_linear</span><span class="p">(</span><span class="n">irreps_edge_feats</span><span class="p">,</span> <span class="n">irreps_edge_feats</span><span class="p">)</span>

<div class="viewcode-block" id="PairInteractionBlock.create_linear">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionBlock.create_linear">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a linear layer.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - irreps_in (o3.Irreps): Input irreps for the linear layer.</span>
<span class="sd">        - irreps_out (o3.Irreps, optional): Output irreps for the linear layer.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - o3.Linear: A linear transformation layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span> <span class="ow">or</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PairInteractionBlock.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.PairInteractionBlock.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the pair interaction block.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - data (Dict[str, torch.Tensor]): A dictionary containing the graph data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - torch.Tensor: Updated edge features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_src</span><span class="p">,</span> <span class="n">edge_dst</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">]</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
        <span class="n">edge_embed</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">]</span>
        <span class="n">edge_feats</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_FEATURES_KEY</span><span class="p">]</span>

        <span class="c1"># Mixing node features for edge features       </span>
        <span class="n">edge_feats_mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_tp</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_src</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)[</span><span class="n">edge_src</span><span class="p">],</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">linear_up_tar</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)[</span><span class="n">edge_dst</span><span class="p">],</span> 
            <span class="n">edge_feats</span><span class="p">,</span> 
            <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_ATTRS_KEY</span><span class="p">],</span> 
            <span class="n">edge_embed</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span><span class="p">:</span>
            <span class="n">edge_feats</span> <span class="o">=</span> <span class="n">edge_feats_mix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_linear</span><span class="p">(</span><span class="n">edge_feats</span><span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_feats</span>
        
        <span class="k">return</span> <span class="n">edge_feats</span></div>
</div>


<div class="viewcode-block" id="CorrProductBlock">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.CorrProductBlock">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CorrProductBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A correlation product block for updating node features using an equivariant product operation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - irreps_node_feats (o3.Irreps): Irreducible representations for node features.</span>
<span class="sd">    - num_hidden_features (int): Number of hidden features.</span>
<span class="sd">    - correlation (int): Correlation level for the product operation.</span>
<span class="sd">    - use_skip_connections (bool): Whether to use skip connections.</span>
<span class="sd">    - num_elements (int): Number of elements for the product operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_node_feats</span><span class="p">:</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">,</span>
        <span class="n">num_hidden_features</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">correlation</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">use_skip_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">num_elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_node_feats</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_hidden_features</span> <span class="o">=</span> <span class="n">num_hidden_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correlation</span> <span class="o">=</span> <span class="n">correlation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span> <span class="o">=</span> <span class="n">use_skip_connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">=</span> <span class="n">num_elements</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_hidden_features</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span>
            <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_hidden_features</span><span class="p">,</span> <span class="n">irrep</span><span class="o">.</span><span class="n">ir</span><span class="p">)</span> <span class="k">for</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Linear layers for lifting and skip connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_pre</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_hidden_features</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_sc</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Equivariant product operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prod</span> <span class="o">=</span> <span class="n">EquivariantProductBasisBlock</span><span class="p">(</span>
            <span class="n">node_feats_irreps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_hidden_features</span><span class="p">,</span>
            <span class="n">target_irreps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_hidden_features</span><span class="p">,</span>
            <span class="n">correlation</span><span class="o">=</span><span class="n">correlation</span><span class="p">,</span>
            <span class="n">num_elements</span><span class="o">=</span><span class="n">num_elements</span><span class="p">,</span>
            <span class="n">use_sc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Linear layer for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_hidden_features</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_node_feats</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span> <span class="o">=</span> <span class="n">reshape_irreps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_hidden_features</span><span class="p">)</span>

<div class="viewcode-block" id="CorrProductBlock.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.CorrProductBlock.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the correlation product block.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - data (Dict[str, torch.Tensor]): A dictionary containing the graph data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - torch.Tensor: Updated node features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_pre</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">])</span>
        <span class="n">node_feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">node_feats</span><span class="p">)</span> <span class="c1"># [n_nodes, channels, (l + 1)**2]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">node_feats</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_ATTRS_KEY</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_out</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_skip_connections</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_sc</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="n">sc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>


<div class="viewcode-block" id="ResidualBlock">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ResidualBlock">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ResidualBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A residual block used in equivariant neural networks.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        irreps_in (str): The input irreducible representations (irreps).</span>
<span class="sd">        feature_irreps_hidden (str): The hidden feature irreps.</span>
<span class="sd">        resnet (bool): If True, apply a residual connection.</span>
<span class="sd">        nonlinearity_type (str): The type of nonlinearity to apply (&#39;gate&#39; or &#39;norm&#39;).</span>
<span class="sd">        nonlinearity_scalars (Dict[int, Callable]): A dictionary mapping parity to nonlinearity functions for scalar features.</span>
<span class="sd">        nonlinearity_gates (Dict[int, Callable]): A dictionary mapping parity to nonlinearity functions for gated features.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irreps_in</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">feature_irreps_hidden</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">resnet</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">nonlinearity_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gate&quot;</span><span class="p">,</span>
        <span class="n">nonlinearity_scalars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;tanh&quot;</span><span class="p">},</span>
        <span class="n">nonlinearity_gates</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;ssp&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">},</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="c1"># Ensure valid nonlinearity type</span>
        <span class="k">assert</span> <span class="n">nonlinearity_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;gate&quot;</span><span class="p">,</span> <span class="s2">&quot;norm&quot;</span><span class="p">),</span> <span class="s2">&quot;Invalid nonlinearity_type. Choose either &#39;gate&#39; or &#39;norm&#39;.&quot;</span>

        <span class="c1"># Convert scalar and gate nonlinearity based on parity</span>
        <span class="n">nonlinearity_scalars</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">]}</span>
        <span class="n">nonlinearity_gates</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">nonlinearity_gates</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">]}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">irreps_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_irreps_hidden</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Irreps</span><span class="p">(</span><span class="n">feature_irreps_hidden</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span> <span class="o">=</span> <span class="n">resnet</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">equivariant_nonlin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_nonlinearity</span><span class="p">(</span><span class="n">nonlinearity_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_irreps_hidden</span><span class="p">,</span> <span class="n">nonlinearity_scalars</span><span class="p">,</span> <span class="n">nonlinearity_gates</span><span class="p">)</span>
        
        <span class="c1"># Define linear layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">equivariant_nonlin</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">irreps_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">equivariant_nonlin</span><span class="o">.</span><span class="n">irreps_out</span><span class="p">,</span> <span class="n">irreps_out</span><span class="o">=</span><span class="n">irreps_in</span><span class="p">)</span>

<div class="viewcode-block" id="ResidualBlock.create_nonlinearity">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ResidualBlock.create_nonlinearity">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_nonlinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonlinearity_type</span><span class="p">,</span> <span class="n">irreps_mid</span><span class="p">,</span> <span class="n">nonlinearity_scalars</span><span class="p">,</span> <span class="n">nonlinearity_gates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create nonlinearity module.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nonlinearity_type</span> <span class="o">==</span> <span class="s2">&quot;gate&quot;</span><span class="p">:</span>
            <span class="n">irreps_scalars</span><span class="p">,</span> <span class="n">irreps_gates</span><span class="p">,</span> <span class="n">irreps_gated</span><span class="p">,</span> <span class="n">act_scalars</span><span class="p">,</span> <span class="n">act_gates</span> <span class="o">=</span> <span class="n">irreps2gate</span><span class="p">(</span>
                <span class="n">irreps_mid</span><span class="p">,</span> <span class="n">nonlinearity_scalars</span><span class="p">,</span> <span class="n">nonlinearity_gates</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Gate</span><span class="p">(</span>
                <span class="n">irreps_scalars</span><span class="o">=</span><span class="n">irreps_scalars</span><span class="p">,</span>
                <span class="n">act_scalars</span><span class="o">=</span><span class="n">act_scalars</span><span class="p">,</span>
                <span class="n">irreps_gates</span><span class="o">=</span><span class="n">irreps_gates</span><span class="p">,</span>
                <span class="n">act_gates</span><span class="o">=</span><span class="n">act_gates</span><span class="p">,</span>
                <span class="n">irreps_gated</span><span class="o">=</span><span class="n">irreps_gated</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">NormActivation</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="n">irreps_mid</span><span class="p">,</span>
            <span class="n">scalar_nonlinearity</span><span class="o">=</span><span class="n">acts</span><span class="p">[</span><span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
            <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ResidualBlock.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.ResidualBlock.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward pass of the residual block.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            x (torch.Tensor): Input tensor with shape matching `irreps_in`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Output tensor with shape matching `irreps_in`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store old input for resnet connection if applicable</span>
        <span class="n">old_x</span> <span class="o">=</span> <span class="n">x</span>
        
        <span class="c1"># Apply first linear transformation</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="c1"># Apply nonlinearity</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivariant_nonlin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="c1"># Apply second linear transformation</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="c1"># Apply residual connection if resnet is enabled</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">old_x</span> <span class="o">+</span> <span class="n">x</span>
            
        <span class="k">return</span> <span class="n">x</span></div>
</div>


<div class="viewcode-block" id="HamLayer">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.HamLayer">[文档]</a>
<span class="nd">@compile_mode</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">HamLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irreps_in</span><span class="p">,</span> <span class="n">feature_irreps_hidden</span><span class="p">,</span> <span class="n">irreps_out</span><span class="p">,</span> <span class="n">nonlinearity_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gate&quot;</span><span class="p">,</span> <span class="n">resnet</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="c1"># Define the residual block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual_block</span> <span class="o">=</span> <span class="n">ResidualBlock</span><span class="p">(</span><span class="n">irreps_in</span><span class="o">=</span><span class="n">irreps_in</span><span class="p">,</span> 
                                            <span class="n">feature_irreps_hidden</span><span class="o">=</span><span class="n">feature_irreps_hidden</span><span class="p">,</span> 
                                            <span class="n">nonlinearity_type</span><span class="o">=</span><span class="n">nonlinearity_type</span><span class="p">,</span> 
                                            <span class="n">resnet</span><span class="o">=</span><span class="n">resnet</span><span class="p">)</span>
        
        <span class="c1"># Define the linear transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_transform</span> <span class="o">=</span> <span class="n">o3</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">irreps_in</span><span class="o">=</span><span class="n">irreps_in</span><span class="p">,</span> <span class="n">irreps_out</span><span class="o">=</span><span class="n">irreps_out</span><span class="p">)</span>
    
<div class="viewcode-block" id="HamLayer.forward">
<a class="viewcode-back" href="../../../../source/gnn_core.html#HamGNN_v_2_0.models.HamGNN.Attention_kan.HamLayer.forward">[文档]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Apply the residual block</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual_block</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="c1"># Apply the linear transformation</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">x</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2025, HamGNN Team。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>